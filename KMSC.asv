function [ d_Y ] = KMSC( D, Y, ktype, rbf_var)
% KMSC -- This is a script which implements the M-ary Kernelized Matched
% Subspace Classifier
% Author: John J. Hall (Jack)
%% Inputs:
% D -- Struct containing M matrices of training samples for the M classes
%    - LAST D should always be background samples
%    - e.g. D(1).D = matrix of vector samples from class 1
%
% Y -- Matrix of dimension NxQ observation samples to be classified

%% Outputs:
% d_Y -- matrix of dimension QxM, these are the statistics of each of the Q
% samples under M different hypotheses

% For any sample, to form the likelihood ratio, under mth hypothesis we need:
% 1) K(T_m,T_m) = KTmTm = kernel(T_m,T_m,ktype,rbf_var)... etc.
% 2) K(T_m,  B) = KTmB
% 3) K(B ,T_m)  = KBTm
% 4) K(B,B)     = KBB
% 5) [del_m ~, ~] = svd(K([T_m,B],[T_m,B])) 
% 6) Lm = [ T'*K(Z_{T_m},Z_{T_m})*T    T'*K(Z_{T_m},Z_{B})*B ; ...
%           B'*K(Z_{B},Z_{T_m})*T      B'*K(Z_{B},Z_{B})*B ]

% For each sample y we need to calculate:
% 1) K([T_m,B],y) = KTmBy
% 2) K(T_m,y)     = KTmy
% 3) K(B,y)       = KBy

d_Y = zeros(size(Y,2),length(D));
for m = length(D)-1
    T_m = D(m).D;           % Class m samples
    Bk  = D(length(D)).D;   % Background samples
    
    KTmTm = kernel(T_m,T_m,ktype,rbf_var);
    KTmB  = kernel(T_m,Bk,ktype,rbf_var);
    KBTm  = kernel(Bk,T_m,ktype,rbf_var);
    KBB   = kernel(Bk,Bk,ktype,rbf_var);
    
    [del_m,~,~] = svd(KTBTB);
    
    [T,eT,~] = svd(KTmTm, 'econ');
    [B,eB,~] = svd(KBB, 'econ');
    for nT = 1:size(eT,1)
        if(trace(eT(1:nT,1:nT).^2)/trace(eT.^2)>0.9) 
            break
        end
    end
    for nB = 1:size(eB,1)
        if(trace(eB(1:nB,1:nB).^2)/trace(eB.^2)>0.9) 
            break
        end
    end
    T = T(:,1:nT);
    B = B(:,1:nB);
    
    Lm = [ T'*KTmTm*T    T'*KTmB*B ; ...
           B'*KBTm*T      B'*KBB*B ];
    
    for q = 1:size(Y,2)
        y = Y(:,q);
        % For each sample y we need to calculate:
        KTmBy = kernel([Tm Bk],y, ktype,rbf_var);
        KTmy  = kernel(Tm,y, ktype,rbf_var);
        KBy   = kernel(Bk,y, ktype,rbf_var);
        
        d_Y(q,m) = (norm(del_m'*KTmBy,'fro')^2-norm(B'*KBy,'fro')^2)...
            /(norm(del_m'*KTmBy,'fro')^2-[KTmy'*T KBy'*B]*Lm^(-1)*[T'*KTmy; B'*KBy]);
    end
    %this can be further simplfied to:
% L_m(y) = 
% num: ( |del_m'*K(Z_{T_m,B},y)|^2_F -|B'*K(Z_{B},y)|_F^2 )./
% den: ( |del_m'*K(Z_{T_m,B},y)|^2_F - [K(Z_{T_m},y)'*T, ...
%        K(Z_{B},y)'*B]*Lm^(-1)*[T'*K(Z_{Tm},y ; B'*K(Z_{B},y] )


%del_m are ALL eigenvectors of K(Z_{T_m,B},Z_{T_m,B}) stacked side by side

% Matrices B and T are the SIGNIFICANT eigenvectors of background centered 
% K(Z_{B},Z_{B}) and K(Z_{T_m},Z_{T_m}) respectively...
    
end

end

